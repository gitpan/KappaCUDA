# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package KappaCUDA;
use base qw(Exporter);
use base qw(DynaLoader);
package KappaCUDAc;
bootstrap KappaCUDA;
package KappaCUDA;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package KappaCUDA;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package KappaCUDA;


############# Class : KappaCUDA::Kappa ##############

package KappaCUDA::Kappa;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Kappa(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Kappa($self);
        delete $OWNER{$self};
    }
}

*Good = *KappaCUDAc::Kappa_Good;
*SetCUDA64Bit = *KappaCUDAc::Kappa_SetCUDA64Bit;
*GetProcess = *KappaCUDAc::Kappa_GetProcess;
*HasProcess = *KappaCUDAc::Kappa_HasProcess;
*RemoveProcess = *KappaCUDAc::Kappa_RemoveProcess;
*Count = *KappaCUDAc::Kappa_Count;
*SetTrace = *KappaCUDAc::Kappa_SetTrace;
*Trace = *KappaCUDAc::Kappa_Trace;
*GetExceptionHandler = *KappaCUDAc::Kappa_GetExceptionHandler;
*SetExceptionHandler = *KappaCUDAc::Kappa_SetExceptionHandler;
*CudaInitFlags = *KappaCUDAc::Kappa_CudaInitFlags;
*Start = *KappaCUDAc::Kappa_Start;
*WaitForAll = *KappaCUDAc::Kappa_WaitForAll;
*ThreadID = *KappaCUDAc::Kappa_ThreadID;
*GetCommandQueue = *KappaCUDAc::Kappa_GetCommandQueue;
*Result = *KappaCUDAc::Kappa_Result;
*BasePath = *KappaCUDAc::Kappa_BasePath;
*GPU = *KappaCUDAc::Kappa_GPU;
*Config = *KappaCUDAc::Kappa_Config;
*CUDAConfig = *KappaCUDAc::Kappa_CUDAConfig;
*GetEvaluator = *KappaCUDAc::Kappa_GetEvaluator;
*Registered = *KappaCUDAc::Kappa_Registered;
*Instance = *KappaCUDAc::Kappa_Instance;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::KappaConfig ##############

package KappaCUDA::KappaConfig;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_KappaConfig($self);
        delete $OWNER{$self};
    }
}

*SetAdditionalConfig = *KappaCUDAc::KappaConfig_SetAdditionalConfig;
*AsString = *KappaCUDAc::KappaConfig_AsString;
*AsBool = *KappaCUDAc::KappaConfig_AsBool;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::ExceptionHandler ##############

package KappaCUDA::ExceptionHandler;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_ExceptionHandler(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_ExceptionHandler($self);
        delete $OWNER{$self};
    }
}

*Catch = *KappaCUDAc::ExceptionHandler_Catch;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Process ##############

package KappaCUDA::Process;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Process($self);
        delete $OWNER{$self};
    }
}

*ProcessKeywordConfig = *KappaCUDAc::Process_ProcessKeywordConfig;
*InitCUDAConfig = *KappaCUDAc::Process_InitCUDAConfig;
*SetExceptionHandler = *KappaCUDAc::Process_SetExceptionHandler;
*RememberAnonymous = *KappaCUDAc::Process_RememberAnonymous;
*DoNotExecute = *KappaCUDAc::Process_DoNotExecute;
*SetTrace = *KappaCUDAc::Process_SetTrace;
*Trace = *KappaCUDAc::Process_Trace;
*SetCommandTrace = *KappaCUDAc::Process_SetCommandTrace;
*CommandTrace = *KappaCUDAc::Process_CommandTrace;
*SetQueueResults = *KappaCUDAc::Process_SetQueueResults;
*ExecuteFile = *KappaCUDAc::Process_ExecuteFile;
*ExecuteString = *KappaCUDAc::Process_ExecuteString;
*GetNamespace = *KappaCUDAc::Process_GetNamespace;
*RegisterIOCallback = *KappaCUDAc::Process_RegisterIOCallback;
*GetIOUserData = *KappaCUDAc::Process_GetIOUserData;
*AddKeywordKeyword = *KappaCUDAc::Process_AddKeywordKeyword;
*RegisterKeywordCommand = *KappaCUDAc::Process_RegisterKeywordCommand;
*RegisterKeywordCommandData = *KappaCUDAc::Process_RegisterKeywordCommandData;
*NewKeywordCommand = *KappaCUDAc::Process_NewKeywordCommand;
*OutputRoutines = *KappaCUDAc::Process_OutputRoutines;
*OutputRoutine = *KappaCUDAc::Process_OutputRoutine;
*LoadRoutine = *KappaCUDAc::Process_LoadRoutine;
*AccessResource = *KappaCUDAc::Process_AccessResource;
*RelinquishResource = *KappaCUDAc::Process_RelinquishResource;
*SetCurrentContextPath = *KappaCUDAc::Process_SetCurrentContextPath;
*GetCurrentContextPath = *KappaCUDAc::Process_GetCurrentContextPath;
*ExecuteRoutine = *KappaCUDAc::Process_ExecuteRoutine;
*ExecuteFunction = *KappaCUDAc::Process_ExecuteFunction;
*ProperRoutineType = *KappaCUDAc::Process_ProperRoutineType;
*GetResult = *KappaCUDAc::Process_GetResult;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Result ##############

package KappaCUDA::Result;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Result(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Result($self);
        delete $OWNER{$self};
    }
}

*Status = *KappaCUDAc::Result_Status;
*Type = *KappaCUDAc::Result_Type;
*Name = *KappaCUDAc::Result_Name;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Namespace ##############

package KappaCUDA::Namespace;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Namespace($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Namespace(@_);
    bless $self, $pkg if defined($self);
}

*Add = *KappaCUDAc::Namespace_Add;
*Get = *KappaCUDAc::Namespace_Get;
*GetKeys = *KappaCUDAc::Namespace_GetKeys;
*Remove = *KappaCUDAc::Namespace_Remove;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Values ##############

package KappaCUDA::Values;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Values($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Values(@_);
    bless $self, $pkg if defined($self);
}

*GetKeys = *KappaCUDAc::Values_GetKeys;
*GetValue = *KappaCUDAc::Values_GetValue;
*Remove = *KappaCUDAc::Values_Remove;
*Size = *KappaCUDAc::Values_Size;
*AddUnidentified = *KappaCUDAc::Values_AddUnidentified;
*AddVariable = *KappaCUDAc::Values_AddVariable;
*AddIndices = *KappaCUDAc::Values_AddIndices;
*Add = *KappaCUDAc::Values_Add;
*GetUint8 = *KappaCUDAc::Values_GetUint8;
*GetUint16 = *KappaCUDAc::Values_GetUint16;
*GetUint32 = *KappaCUDAc::Values_GetUint32;
*GetFloat = *KappaCUDAc::Values_GetFloat;
*GetBool = *KappaCUDAc::Values_GetBool;
*GetUint64 = *KappaCUDAc::Values_GetUint64;
*GetDouble = *KappaCUDAc::Values_GetDouble;
*GetPointer = *KappaCUDAc::Values_GetPointer;
*GetString = *KappaCUDAc::Values_GetString;
*GetVariable = *KappaCUDAc::Values_GetVariable;
*GetNamespace_Value = *KappaCUDAc::Values_GetNamespace_Value;
*GetIndices = *KappaCUDAc::Values_GetIndices;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Value ##############

package KappaCUDA::Value;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Value($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Value(@_);
    bless $self, $pkg if defined($self);
}

*Type = *KappaCUDAc::Value_Type;
*Union = *KappaCUDAc::Value_Union;
*SetStringType = *KappaCUDAc::Value_SetStringType;
*CopyValue = *KappaCUDAc::Value_CopyValue;
*Free = *KappaCUDAc::Value_Free;
*Set = *KappaCUDAc::Value_Set;
*Prepare = *KappaCUDAc::Value_Prepare;
*Resolve = *KappaCUDAc::Value_Resolve;
*Get = *KappaCUDAc::Value_Get;
*Size = *KappaCUDAc::Value_Size;
*GetExpression = *KappaCUDAc::Value_GetExpression;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Resource ##############

package KappaCUDA::Resource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Resource($self);
        delete $OWNER{$self};
    }
}

*SetCurrentByType = *KappaCUDAc::Resource_SetCurrentByType;
*SetCurrentByTypeName = *KappaCUDAc::Resource_SetCurrentByTypeName;
*SetDependencyByTypes = *KappaCUDAc::Resource_SetDependencyByTypes;
*SetDependencyByType = *KappaCUDAc::Resource_SetDependencyByType;
*SetDependencyByTypeName = *KappaCUDAc::Resource_SetDependencyByTypeName;
*SetFinalByType = *KappaCUDAc::Resource_SetFinalByType;
*SetFinalByTypeName = *KappaCUDAc::Resource_SetFinalByTypeName;
*CommandResources = *KappaCUDAc::Resource_CommandResources;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Instruction ##############

package KappaCUDA::Instruction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Instruction($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Instruction(@_);
    bless $self, $pkg if defined($self);
}

*AddOriginalName = *KappaCUDAc::Instruction_AddOriginalName;
*GetOriginalName = *KappaCUDAc::Instruction_GetOriginalName;
*GetKeyword = *KappaCUDAc::Instruction_GetKeyword;
*GetName = *KappaCUDAc::Instruction_GetName;
*GetAttributes = *KappaCUDAc::Instruction_GetAttributes;
*GetArguments = *KappaCUDAc::Instruction_GetArguments;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Attributes ##############

package KappaCUDA::Attributes;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA::Values KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Attributes(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Attributes($self);
        delete $OWNER{$self};
    }
}

*Prepare = *KappaCUDAc::Attributes_Prepare;
*Resolve = *KappaCUDAc::Attributes_Resolve;
*Get = *KappaCUDAc::Attributes_Get;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Arguments ##############

package KappaCUDA::Arguments;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Arguments($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_Arguments(@_);
    bless $self, $pkg if defined($self);
}

*Reset = *KappaCUDAc::Arguments_Reset;
*Size = *KappaCUDAc::Arguments_Size;
*Add = *KappaCUDAc::Arguments_Add;
*TexRef = *KappaCUDAc::Arguments_TexRef;
*Out = *KappaCUDAc::Arguments_Out;
*IO = *KappaCUDAc::Arguments_IO;
*In = *KappaCUDAc::Arguments_In;
*Type = *KappaCUDAc::Arguments_Type;
*Direction = *KappaCUDAc::Arguments_Direction;
*Get = *KappaCUDAc::Arguments_Get;
*GetIndices = *KappaCUDAc::Arguments_GetIndices;
*GetValue = *KappaCUDAc::Arguments_GetValue;
*Prepare = *KappaCUDAc::Arguments_Prepare;
*Resolve = *KappaCUDAc::Arguments_Resolve;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::ProcessControlBlock ##############

package KappaCUDA::ProcessControlBlock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = KappaCUDAc::new_ProcessControlBlock(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_ProcessControlBlock($self);
        delete $OWNER{$self};
    }
}

*SetCUDA64Bit = *KappaCUDAc::ProcessControlBlock_SetCUDA64Bit;
*PitchWidth = *KappaCUDAc::ProcessControlBlock_PitchWidth;
*Result = *KappaCUDAc::ProcessControlBlock_Result;
*Running = *KappaCUDAc::ProcessControlBlock_Running;
*Stop = *KappaCUDAc::ProcessControlBlock_Stop;
*Done = *KappaCUDAc::ProcessControlBlock_Done;
*GetKappa = *KappaCUDAc::ProcessControlBlock_GetKappa;
*Data = *KappaCUDAc::ProcessControlBlock_Data;
*LocalDevice = *KappaCUDAc::ProcessControlBlock_LocalDevice;
*ThreadID = *KappaCUDAc::ProcessControlBlock_ThreadID;
*GetCommandQueue = *KappaCUDAc::ProcessControlBlock_GetCommandQueue;
*CommandQueueSize = *KappaCUDAc::ProcessControlBlock_CommandQueueSize;
*IsCurrentContext = *KappaCUDAc::ProcessControlBlock_IsCurrentContext;
*PopContexts = *KappaCUDAc::ProcessControlBlock_PopContexts;
*GetContext = *KappaCUDAc::ProcessControlBlock_GetContext;
*NewContext = *KappaCUDAc::ProcessControlBlock_NewContext;
*GPUDevice = *KappaCUDAc::ProcessControlBlock_GPUDevice;
*GPUDeviceName = *KappaCUDAc::ProcessControlBlock_GPUDeviceName;
*GPU = *KappaCUDAc::ProcessControlBlock_GPU;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : KappaCUDA::Context ##############

package KappaCUDA::Context;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( KappaCUDA );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        KappaCUDAc::delete_Context($self);
        delete $OWNER{$self};
    }
}

*PitchWidth = *KappaCUDAc::Context_PitchWidth;
*SetCUDA64Bit = *KappaCUDAc::Context_SetCUDA64Bit;
*SetCUcontext = *KappaCUDAc::Context_SetCUcontext;
*GetCUcontext = *KappaCUDAc::Context_GetCUcontext;
*ContextType = *KappaCUDAc::Context_ContextType;
*GetProcessControlBlock = *KappaCUDAc::Context_GetProcessControlBlock;
*GetStream = *KappaCUDAc::Context_GetStream;
*Copy = *KappaCUDAc::Context_Copy;
*FreeVariable = *KappaCUDAc::Context_FreeVariable;
*New = *KappaCUDAc::Context_New;
*NewLocalAndDevice = *KappaCUDAc::Context_NewLocalAndDevice;
*NewLocalOnly = *KappaCUDAc::Context_NewLocalOnly;
*NewDevice = *KappaCUDAc::Context_NewDevice;
*NewDevicePitch = *KappaCUDAc::Context_NewDevicePitch;
*NewDeviceOnly = *KappaCUDAc::Context_NewDeviceOnly;
*ModuleTexture = *KappaCUDAc::Context_ModuleTexture;
*ModuleVariable = *KappaCUDAc::Context_ModuleVariable;
*GetVariable = *KappaCUDAc::Context_GetVariable;
*CreateModule = *KappaCUDAc::Context_CreateModule;
*CreateCModule = *KappaCUDAc::Context_CreateCModule;
*CreateArray = *KappaCUDAc::Context_CreateArray;
*GetModule = *KappaCUDAc::Context_GetModule;
*GetCModule = *KappaCUDAc::Context_GetCModule;
*GetArray = *KappaCUDAc::Context_GetArray;
*UnloadModule = *KappaCUDAc::Context_UnloadModule;
*Synchronize = *KappaCUDAc::Context_Synchronize;
*Free = *KappaCUDAc::Context_Free;
*UnloadModules = *KappaCUDAc::Context_UnloadModules;
*Reset = *KappaCUDAc::Context_Reset;
*Push = *KappaCUDAc::Context_Push;
*Pop = *KappaCUDAc::Context_Pop;
*Result = *KappaCUDAc::Context_Result;
*MemoryFree = *KappaCUDAc::Context_MemoryFree;
*MemoryTotal = *KappaCUDAc::Context_MemoryTotal;
*MemoryUsed = *KappaCUDAc::Context_MemoryUsed;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package KappaCUDA;

*KAPPA_DLL = *KappaCUDAc::KAPPA_DLL;
*MAX_GPUS = *KappaCUDAc::MAX_GPUS;
*PROCESSES_INC = *KappaCUDAc::PROCESSES_INC;
*Direction_In = *KappaCUDAc::Direction_In;
*Direction_Out = *KappaCUDAc::Direction_Out;
*Direction_IO = *KappaCUDAc::Direction_IO;
*Direction_TexRef = *KappaCUDAc::Direction_TexRef;
*ROUTINE_LOOP_NAMESPACE = *KappaCUDAc::ROUTINE_LOOP_NAMESPACE;
*ROUTINE_LOOP_NAME = *KappaCUDAc::ROUTINE_LOOP_NAME;

$KappaCUDA::VERSION = '1.1.0';
1;
